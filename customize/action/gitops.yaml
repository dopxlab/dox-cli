configure: |
  dox export APP_GITOPS_VARIABLES

template:
  folder: "${DOX_CUSTOM_DIR}/action/templates/gitops" # ${template_folder} will be resolved path of the template folder 
  variables:
    BUILD_VERSION: "${BUILD_VERSION}"
    APPLICATION_NAME: "${APPLICATION_NAME:-$GIT_REPOSITORY_NAME}"

    CONFIG_MAP_NAME: "${CONFIG_MAP_NAME:-}"
    CONFIG_MAP_MOUNT_PATH: "${CONFIG_MAP_MOUNT_PATH:-}"

    SECRET_NAME: "${SECRET_NAME:-}"
    SECRET_MOUNT_PATH: "${SECRET_MOUNT_PATH:-}"

    PVC_NAME: "${PVC_NAME:-}"
    PVC_MOUNT_PATH: "${PVC_MOUNT_PATH:-}"

    SERVICE_ACCOUNT_NAME: "${SERVICE_ACCOUNT_NAME:-default}"

    IMAGE_PULL_SECRET_NAME: "${IMAGE_PULL_SECRET_NAME:-}" 

actions:
  update-image-tag: |
    #!/bin/bash
    # Script to merge YAML files and update main configuration
    # Usage: ./merge_yaml.sh
    # Environment variables required:
    # - STAGE: Target environment (dev, staging, prod, etc.)
    # - GITOPS_PAT: Personal Access Token for GitOps repository
    # - GITOPS_REPO: GitOps repository URL (e.g., github.com/user/repo.git)
    set -e

    # Parameters
    APP_NAME="${APPLICATION_NAME:-demo-app}"  # Can be overridden by environment variable
    STAGE="${STAGE:-dev}"  # Default to 'dev' if STAGE is not set
    GITOPS_PAT="${GITOPS_PAT}"  # GitOps Personal Access Token
    GITOPS_REPO="${GITOPS_REPO}"  # GitOps repository URL (without https://)
    TMP_DIR="/tmp/gitops-$(date +%s)"  # Temporary directory for git clone

    # Clone the GitOps repository
    echo "Cloning GitOps repository..."
    git clone --depth 1 "https://${GITOPS_PAT}@${GITOPS_REPO}" "$TMP_DIR"

    # Update paths to use the cloned repository
    MAIN_YAML="$TMP_DIR/argo-apps/values-${STAGE}.yaml"
    GITOPS_VALUES="${template_folder}/gitops-argocd-values.yaml"
    VALUES_YAML="$(pwd)/values.yaml"

    # Temporary files
    TEMP_MERGED="/tmp/merged_temp.yaml"
    TEMP_CLEANED="/tmp/cleaned_temp.yaml"
    TEMP_MAIN="/tmp/main_temp.yaml"

    echo "Merging YAML files for application: $APP_NAME in $STAGE environment"

    # Verify required files exist
    if [[ ! -f "$GITOPS_VALUES" ]]; then
      echo "❌ Error: GitOps values file not found: $GITOPS_VALUES"
      exit 1
    fi

    if [[ ! -f "$MAIN_YAML" ]]; then
      echo "❌ Error: Main YAML file not found: $MAIN_YAML"
      exit 1
    fi

    # Check if application exists, if not add it to applications array
    if ! yq eval ".applications[] | select(.name == \"$APP_NAME\") | .name" "$MAIN_YAML" | grep -q "$APP_NAME"; then
      echo "Application $APP_NAME does not exist - adding new entry"
      yq eval ".applications += [{\"name\": \"$APP_NAME\"}]" "$MAIN_YAML" > "$TEMP_MAIN"
      mv "$TEMP_MAIN" "$MAIN_YAML"
      echo "Added new application: $APP_NAME"
    fi

    # Check if VALUES_YAML exists
    if [[ -f "$VALUES_YAML" ]]; then
      echo "Found values.yaml file - will merge with GitOps values"
      USE_VALUES_YAML=true
    else
      echo "No values.yaml file found - using only GitOps values"
      USE_VALUES_YAML=false
    fi

    # Step 1: Merge files (conditionally)
    if [[ "$USE_VALUES_YAML" == "true" ]]; then
      # Merge both files
      yq eval-all 'select(fileIndex == 0) * select(fileIndex == 1)' "$GITOPS_VALUES" "$VALUES_YAML" > "$TEMP_MERGED"
      echo "Step 1: Merged $GITOPS_VALUES and $VALUES_YAML"
    else
      # Use only GitOps values
      cp "$GITOPS_VALUES" "$TEMP_MERGED"
      echo "Step 1: Using only $GITOPS_VALUES (no values.yaml found)"
    fi

    # Step 2: Clean null, empty string, and empty objects using jq (improved cleaning)
    yq -o=json eval '.' "$TEMP_MERGED" |
    jq 'def clean:
          walk(
            if type == "object" then
              with_entries(
                select(
                  .value != null and
                  .value != "" and
                  .value != [] and
                  (if (.value | type == "object") then (.value | keys | length > 0) else true end) and
                  (if (.value | type == "array") then (.value | length > 0) else true end)
                )
              ) |
              # Remove the object itself if it becomes empty after filtering
              if keys | length == 0 then empty else . end
            elif type == "array" then
              map(select(. != null and . != "" and . != [])) |
              if length == 0 then empty else . end
            else .
            end
          );
        clean | clean | clean' |
    yq -P > "$TEMP_CLEANED"
    echo "Step 2: Cleaned empty and null values from merged file"

    # Step 3: Add name to cleaned config
    yq eval ".name = \"$APP_NAME\"" "$TEMP_CLEANED" > "$TEMP_CLEANED.tmp"
    mv "$TEMP_CLEANED.tmp" "$TEMP_CLEANED"

    # Step 4: Add or replace application configuration
    # Check if application exists and handle accordingly
    if yq eval ".applications[] | select(.name == \"$APP_NAME\") | .name" "$MAIN_YAML" | grep -q "$APP_NAME"; then
      # Application exists - merge it (use *= instead of =)
      yq eval "
        (.applications[] | select(.name == \"$APP_NAME\")) *= load(\"$TEMP_CLEANED\")
      " "$MAIN_YAML" > "$TEMP_MAIN"
      echo "Step 4: Merged configuration into existing application $APP_NAME"
    else
      # Application doesn't exist - add it
      yq eval "
        .applications += [load(\"$TEMP_CLEANED\")]
      " "$MAIN_YAML" > "$TEMP_MAIN"
      echo "Step 4: Added new application $APP_NAME with cleaned configuration"
    fi

    # Replace the original main file
    mv "$TEMP_MAIN" "$MAIN_YAML"
    # Display the result
    echo ""
    echo "Updated main YAML content:"
    echo "=========================="
    cat "$MAIN_YAML"

    # Step 4: Commit and push changes
    cd "$TMP_DIR"
    git config user.email "ci@example.com"
    git config user.name "CI Bot"
    git add "argo-apps/values-${STAGE}.yaml"
    git commit -m "Update $APP_NAME configuration for $STAGE environment"
    git push origin main

    echo "✅ Successfully committed and pushed changes to GitOps repository"

    # Step 5: Cleanup
    cd - > /dev/null
    rm -rf "$TMP_DIR"
    rm -f "$TEMP_MERGED" "$TEMP_CLEANED"

    echo "✅ Successfully merged, cleaned, and updated values-${STAGE}.yaml"
    echo "Updated configuration for application: $APP_NAME in $STAGE environment"